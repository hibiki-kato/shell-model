#include "Runge_Kutta.hpp"
#include <eigen3/Eigen/Dense>
#include <complex>
#include <cmath>
#include <math.h>
#include <chrono>
#include <iostream>
#include <regex>
#include <random>
#include <omp.h>

LongLaminar::LongLaminar(double input_nu, double input_beta, std::complex<double> input_f, double input_ddt, double input_t_0, double input_t, double input_latter, Eigen::VectorXcd input_x_0, Eigen::MatrixXcd input_laminar, double input_epsilon, int input_skip, double input_check_sec, double input_progress_sec, int input_threads = omp_get_num_threads()) : ShellModel(input_nu, input_beta, input_f, input_ddt, input_t_0, input_t, input_latter, input_x_0){
    laminar = input_laminar;
    epsilon = input_epsilon;
    skip = input_skip;
    check_sec = input_check_sec;
    progress_sec = input_progress_sec;
    begin_time_of_stag_and_step = input_t_0;
    end_time_of_stag_and_step = input_t;
    threads = input_threads;
}

LongLaminar::~LongLaminar(){
}

Eigen::MatrixXcd LongLaminar::stagger_and_step_(){
    Eigen::MatrixXcd staggered_traj = Eigen::MatrixXcd::Zero(ShellModel::get_x_0_().size()+1, ShellModel::get_steps_()+1); // trajectory going to be generated by stagger and step
    int stagger_and_step_num = static_cast<int>((end_time_of_stag_and_step - begin_time_of_stag_and_step) / progress_sec + 0.5); // times of stagger and step
    int check_steps = static_cast<int>(check_sec / ShellModel::get_ddt_() + 0.5); //steps of checked trajectory
    int progress_steps = static_cast<int>(progress_sec / ShellModel::get_ddt_() + 0.5); //steps of progress
    int cycle_limit = 2E+05;
    ShellModel::set_steps_(check_steps);
    
    for (int i = 0; i < stagger_and_step_num; i++){
        std::cout << "\r 現在" << i * progress_sec << "時間" << std::flush;
        ShellModel::set_t_(ShellModel::get_t_0_() + check_sec);

        // no perturbation at first
        Eigen::MatrixXcd checked_traj = ShellModel::get_trajectory_();
        if (LongLaminar::isLaminarTrajectory_(checked_traj)){
            staggered_traj.middleCols(i*progress_steps, progress_steps+1) = checked_traj.leftCols(progress_steps+1);
            ShellModel::set_t_0_(ShellModel::get_t_0_() + progress_sec);
            ShellModel::set_x_0_(checked_traj.block(0, progress_steps, ShellModel::get_x_0_().size(), 1));
        }
        else{
            std::cout << std::endl;
            bool exit = false;
            // parallel
            #pragma omp parallel num_threads(threads)
            {   int local_threads = threads;
                int local_counter = 0;
                int local_cycle_limit = cycle_limit;
                int thread_id = omp_get_thread_num();
                while (true) {
                    local_counter++;
                    ShellModel::set_x_0_(LongLaminar::perturbator_(ShellModel::get_x_0_()));
                    Eigen::MatrixXcd checked_traj = ShellModel::get_trajectory_();
                    if (LongLaminar::isLaminarTrajectory_(checked_traj)) {
                        #pragma omp single 
                        {
                            staggered_traj.middleCols(i * progress_steps, progress_steps + 1) = checked_traj.leftCols(progress_steps + 1);
                            ShellModel::set_t_0_(ShellModel::get_t_0_() + progress_sec);
                            ShellModel::set_x_0_(checked_traj.block(0, progress_steps, ShellModel::get_x_0_().size(), 1));
                            std::cout << std::endl;
                        }
                        break;
                    }
                    if (local_counter >= local_cycle_limit / local_threads) {
                        #pragma omp single
                        exit = true;
                        break;
                    }
                    if (thread_id == 0){
                        std::cout << "\r 現在試行" << local_counter * local_threads << std::flush;
                    }
                }
            }   
            if (exit){
                return staggered_traj.leftCols(i*progress_steps+1);
            }
        }
    }
    return staggered_traj;
}

bool LongLaminar::isLaminarPoint_(Eigen::VectorXcd state){
// if the points is in laminar flow, return true. Otherwise return false.  state can include time bcause it will be dropped.
    int row_start = 0;
    int row_end = 4;
    Eigen::VectorXd distance = (laminar.middleRows(row_start, row_end).cwiseAbs() - state.middleRows(row_start, row_end).replicate(1, laminar.cols()).cwiseAbs()).colwise().norm();

    return (distance.array() < epsilon).any();
}

bool LongLaminar::isLaminarTrajectory_(Eigen::MatrixXcd trajectory){
    for (int i = 0; i < trajectory.cols()/skip; i++){
        if (!isLaminarPoint_(trajectory.col(i*skip))) {
            return false;
        }
    }
    return true;
}
Eigen::VectorXcd LongLaminar::perturbator_(Eigen::VectorXcd state){   
    std::random_device rd;
    std::mt19937 gen(rd());
    double a = -3;
    double b = -10;
    std::uniform_real_distribution<double> s(-1, 1);
    std::uniform_real_distribution<double> dis(b, a);

    Eigen::VectorXd unit = Eigen::VectorXd::Ones(state.rows());
    for(int i = 0; i < state.rows(); i++){
        unit(i) = s(gen);
    }

    Eigen::VectorXcd u = state.cwiseProduct(unit);
    u /= u.norm();

    return (u.array() * std::pow(10, dis(gen)) + state.array()).matrix();

}

double LongLaminar::laminar_duration_max_(const Eigen::MatrixXcd& trajectory){
    // get binary sequence of whether laminar or not
    int check_times;
    std::vector<int> sequence;
    if (trajectory.rows() == 0){
        check_times = (ShellModel::get_steps_()+1)/skip + 1;
        sequence.resize(check_times);
        Eigen::VectorXcd x = ShellModel::get_x_0_();
        // calc trajectory and check whether laminar or not for "check_times" times
        for (int i = 0; i < ShellModel::get_steps_() ; i++){
            x = ShellModel::rk4_(x);
            if (i % skip == 0){
                sequence[i/skip] = LongLaminar::isLaminarPoint_(x);
            }
        }
    }
    else{
        check_times = trajectory.cols()/skip + 1;
        sequence.resize(check_times);
        for(int i =0; i < check_times; i++){
            sequence[i] = LongLaminar::isLaminarPoint_(trajectory.col(i*skip));
        }
    }

    std::string sequenceString;
    for (int num : sequence) {
        sequenceString += std::to_string(num);
    }

    std::regex pattern("1+"); // パターン: 1が1回以上連続する

    std::smatch match;
    double maxConsecutiveOnes = 0;

    auto it = sequenceString.cbegin();
    while (std::regex_search(it, sequenceString.cend(), match, pattern)) {
        int consecutiveOnes = match.str().length();
        if (consecutiveOnes > maxConsecutiveOnes) {
            maxConsecutiveOnes = consecutiveOnes;
        }
        it = match.suffix().first; // 次の検索の開始位置を設定
    }

    return maxConsecutiveOnes * ShellModel::get_ddt_() * skip;
}

double LongLaminar::laminar_duration_mean_(const Eigen::MatrixXcd& trajectory){
    // get binary sequence of whether laminar or not
    int check_times;
    std::vector<int> sequence;
    if (trajectory.rows() == 0){
        check_times = (ShellModel::get_steps_()+1)/skip + 1;
        sequence.resize(check_times);
        Eigen::VectorXcd x = ShellModel::get_x_0_();
        // calc trajectory and check whether laminar or not for "check_times" times
        for (int i = 0; i < ShellModel::get_steps_() ; i++){
            x = ShellModel::rk4_(x);
            if (i % skip == 0){
                sequence[i/skip] = LongLaminar::isLaminarPoint_(x);
            }
        }
    }
    else{
        check_times = trajectory.cols()/skip + 1;
        sequence.resize(check_times);
        for(int i =0; i < check_times; i++){
            sequence[i] = LongLaminar::isLaminarPoint_(trajectory.col(i*skip));
        }
    }

    int consecutiveOnes = 0;  // 連続している1の数
    int consecutiveBlocks = 0;  // 1の連続ブロックの数
    bool inBlock = false;  // 1の連続ブロック内にいるかどうかのフラグ

    for (int num : sequence) {
        if (num == 1) {
            if (!inBlock) {
                inBlock = true;
                consecutiveBlocks++;
            }
            consecutiveOnes++;
        } else {
            inBlock = false;
        }
    }

    if (consecutiveBlocks == 0) {
        return 0.0;  // 1の連続ブロックが存在しない場合は0を返す
    }

    return static_cast<double>(consecutiveOnes) / consecutiveBlocks * ShellModel::get_ddt_() * skip;
}

double LongLaminar::laminar_duration_(Eigen::MatrixXcd trajectory){
    double duration = 0;
    for (int i = 0; i < trajectory.cols()/skip; i++){
        if (!isLaminarPoint_(trajectory.col(i*skip))) {
            return duration;
        }
        duration += ShellModel::get_ddt_() * skip;
    }
    return duration;
}

