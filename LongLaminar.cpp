#include "Runge_Kutta.hpp"
#include <eigen3/Eigen/Dense>
#include <complex>
#include <cmath>
#include <math.h>
#include <random>
#include <omp.h>

LongLaminar::LongLaminar(double input_nu, double input_beta, std::complex<double> input_f, double input_ddt, double input_t_0, double input_t, double input_latter, Eigen::VectorXcd input_x_0, Eigen::MatrixXcd laminar, double input_epsilon, double input_check_sec, double input_progress_sec, int input_threads = omp_get_num_threads()) : ShellModel(double input_nu, double input_beta, std::complex<double> input_f, double input_ddt, double input_t_0, double input_t, double input_latter, Eigen::VectorXcd input_x_0)
{
    Eigen::MatrixXcd laminar = input_laminar;
    double epsilon = input_epsilon;
    double check_sec = input_check_sec;
    double progress_sec = input_progress_sec;
    double begin_time_of_stag_and_step = input_t_0;
    double end_time_of_stag_and_step = input_t;
    int threads = input_threads;
}

LongLaminar::~LongLaminar()
{
}

Eigen::MatrixXcd LongLaminar::stagger_and_step_()
{
    Eigen::MatrixXcd staggered_traj = Eigen::MatrixXcd::Zero(x_0.dim(), steps); // trajectory being generated by stagger and step
    int stagger_and_step_num = static_cast<int>((end_time_of_stag_and_step - begin_time_of_stag_and_step) / process_sec + 0.5); // times of stagger and step
    int check_step = static_cast<int>(check_sec / ddt + 0.5); //steps of checked trajectory
    int progress_step = static_cast<int>(progress_sec / ddt + 0.5); //steps of progress
    int cycle_limit = 1E+05;
    
    for (int i = 0; i < stagger_and_step_num; i++){
        // displaying the time every 100 seconds
        if (fmod(staggered_traj(i*progress_step, x_0.size()), 100.0) == 0){
            std::cout << static_cast<int>(staggered_traj(i*progress_step, x_0.size()) + 0.5) << std::endl;
        }

        t = t_0 + check_sec;

        // no perturbation at first
        Eigen::MatrixXcd checked_traj = ShellModel::get_trajectory_();

        // 一応エラーメッセージ（消します）
        if (checked_traj.cols() != check_step+1{
            std::cout << "check_sec: " << check_step+1 << std::endl;
            std::cout << "checked_traj.cols(): " << checked_traj.cols() << std::endl;
            std::cout << "Errror チェックの行数がちがいます" << std::endl;
            exit();
        }
        if (LongLaminar::isLaminar_trajectory_(checked_traj)){
            staggered_matrix.middleCols(i*progress_step, progress_step+1) = checked_traj.LeftCols(progress_step+1);
            t_0 = t;
            x_0 = checked_traj.topRightCorner(x_0.size(), 1);
        }
        else{
            // parallel
            counter = 0
            #pragma omp parallel num_threads(threads)
            {  
                while(true){
                    counter++;
                    x_0 = LongLaminar::perturbator_(x_0);
                    checked_traj = ShellModel::get_trajectory_();
                    if (LongLaminar::isLaminar_trajectory_(checked_traj)){
                        staggered_matrix.middleCols(i*progress_step, progress_step+1) = checked_traj.LeftCols(progress_step+1);
                        t_0 = t;
                        x_0 = checked_traj.topRightCorner(x_0.size(), 1);
                        break;
                    }
                    if (counter >= cycle_limit){
                        return staggered_traj.leftCols(progress_step+1);
                    }

                }
            }
        }
    }
    return staggered_traj;
}

bool LongLaminar::isLaminarPoint_(Eigen::VectorXcd state)
// if the points is in laminar flow, return true. Otherwise return false.
{   
    int row_start = 0;
    int row_end = state.rows() - 1;
    Eigen::VectorXd distance = (laminar.middleRows(row_start, row_end).cwiseAbs() - state.middleRows(row_start, row_end).replicate(1, laminar.cols()).cwiseAbs()).colwise().norm();

    return (distance.array() < epsilon).any();
}

bool LongLaminar::isLaminarTrajectory_(Eigen::MatrixXcd trajectory)
{
    for (int i = 0; i < state.cols(); i++){
        if (!isLaminarPoint_(trajectory.col(i))) {
            return false;
        }
    }
    return true;
}
Eigen::VectorXcd LongLaminar::perturbator_(Eigen::VectorXcd state)
{   
    std::random_device rd;
    std::mt19937 gen(rd());
    double a = -3;
    double b = -10;
    std::uniform_real_distribution<double> s(-1, 1);
    std::uniform_real_distribution<double> dis(b, a);

    Eigen::VectorXd unit = Eigen::VectorXd::Ones(state.rows());
    for(int i = 0; i < state.rows(); i++){
        unit(i) = dis(gen);
    }

    Eigen::VectorXcd u = state.cwiseProduct(unit);
    u /= u.norm();

    return (u.array() * std::pow(10, dis(gen)) + state.array()).matrix();

}

