#include "Runge_Kutta.hpp"
#include <eigen3/Eigen/Dense>
#include <complex>
#include <cmath>
#include <math.h>
#include <chrono>
#include <iostream>
#include <random>
#include <omp.h>

LongLaminar::LongLaminar(double input_nu, double input_beta, std::complex<double> input_f, double input_ddt, double input_t_0, double input_t, double input_latter, Eigen::VectorXcd input_x_0, Eigen::MatrixXcd input_laminar, double input_epsilon, int input_skip, double input_check_sec, double input_progress_sec, int input_threads = omp_get_num_threads()) : ShellModel(input_nu, input_beta, input_f, input_ddt, input_t_0, input_t, input_latter, input_x_0){
    laminar = input_laminar;
    epsilon = input_epsilon;
    skip = input_skip;
    check_sec = input_check_sec;
    progress_sec = input_progress_sec;
    begin_time_of_stag_and_step = input_t_0;
    end_time_of_stag_and_step = input_t;
    threads = input_threads;
}

LongLaminar::~LongLaminar(){
}

Eigen::MatrixXcd LongLaminar::stagger_and_step_(){
    Eigen::MatrixXcd staggered_traj = Eigen::MatrixXcd::Zero(ShellModel::get_x_0_().size()+1, ShellModel::get_steps_()+1); // trajectory going to be generated by stagger and step
    int stagger_and_step_num = static_cast<int>((end_time_of_stag_and_step - begin_time_of_stag_and_step) / progress_sec + 0.5); // times of stagger and step
    int check_steps = static_cast<int>(check_sec / ShellModel::get_ddt_() + 0.5); //steps of checked trajectory
    int progress_steps = static_cast<int>(progress_sec / ShellModel::get_ddt_() + 0.5); //steps of progress
    int cycle_limit = 1E+05;
    ShellModel::set_steps_(check_steps);
    
    for (int i = 0; i < stagger_and_step_num; i++){
        // displaying the time every 100 seconds
        // if (fmod(std::abs(staggered_traj(ShellModel::get_x_0_().size(), i * progress_steps)), 100.0) == 0){
        //     std::cout << "\r 現在" << static_cast<int>(std::abs(staggered_traj(ShellModel::get_x_0_().size(), i * progress_steps)) + 0.5) << "時間" << std::flush;
        // }
        std::cout << "\r 現在" << i * progress_sec << "時間" << std::flush;
        ShellModel::set_t_(ShellModel::get_t_0_() + check_sec);

        // no perturbation at first
        Eigen::MatrixXcd checked_traj = ShellModel::get_trajectory_();
        if (LongLaminar::isLaminarTrajectory_(checked_traj)){
            staggered_traj.middleCols(i*progress_steps, progress_steps+1) = checked_traj.leftCols(progress_steps+1);
            ShellModel::set_t_0_(ShellModel::get_t_0_() + progress_sec);
            ShellModel::set_x_0_(checked_traj.block(0, progress_steps, ShellModel::get_x_0_().size(), 1));
        }
        else{
            std::cout << std::endl;
            bool exit = false;
            // parallel
            #pragma omp parallel num_threads(threads)
            {   int local_threads = threads;
                int local_counter = 0;
                int local_cycle_limit = cycle_limit;
                int thread_id = omp_get_thread_num();
                while (true) {
                    local_counter++;
                    ShellModel::set_x_0_(LongLaminar::perturbator_(ShellModel::get_x_0_()));
                    Eigen::MatrixXcd checked_traj = ShellModel::get_trajectory_();
                    if (LongLaminar::isLaminarTrajectory_(checked_traj)) {
                        #pragma omp single 
                        {
                            staggered_traj.middleCols(i * progress_steps, progress_steps + 1) = checked_traj.leftCols(progress_steps + 1);
                            ShellModel::set_t_0_(ShellModel::get_t_0_() + progress_sec);
                            ShellModel::set_x_0_(checked_traj.block(0, progress_steps, ShellModel::get_x_0_().size(), 1));
                        }
                        break;
                    }
                    if (local_counter >= local_cycle_limit / local_threads) {
                        #pragma omp atomic write
                        exit = true;
                        break;
                    }
                    if (thread_id == 0){
                        std::cout << "\r 現在試行" << local_counter * local_threads << std::flush;
                    }
                }
            }   
            if (exit){
                return staggered_traj.leftCols(i*progress_steps+1);
            }
        }
    }
    return staggered_traj;
}

bool LongLaminar::isLaminarPoint_(Eigen::VectorXcd state){
// if the points is in laminar flow, return true. Otherwise return false.   
    int row_start = 0;
    int row_end = 4;
    Eigen::VectorXd distance = (laminar.middleRows(row_start, row_end).cwiseAbs() - state.middleRows(row_start, row_end).replicate(1, laminar.cols()).cwiseAbs()).colwise().norm();

    return (distance.array() < epsilon).any();
}

bool LongLaminar::isLaminarTrajectory_(Eigen::MatrixXcd trajectory){
    for (int i = 0; i < trajectory.cols()/skip; i++){
        if (!isLaminarPoint_(trajectory.col(i*skip))) {
            return false;
        }
    }
    return true;
}
Eigen::VectorXcd LongLaminar::perturbator_(Eigen::VectorXcd state){   
    std::random_device rd;
    std::mt19937 gen(rd());
    double a = -3;
    double b = -10;
    std::uniform_real_distribution<double> s(-1, 1);
    std::uniform_real_distribution<double> dis(b, a);

    Eigen::VectorXd unit = Eigen::VectorXd::Ones(state.rows());
    for(int i = 0; i < state.rows(); i++){
        unit(i) = dis(gen);
    }

    Eigen::VectorXcd u = state.cwiseProduct(unit);
    u /= u.norm();

    return (u.array() * std::pow(10, dis(gen)) + state.array()).matrix();

}

